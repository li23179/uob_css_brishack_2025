/*! For license information please see tsparticles.interaction.light.min.js.LICENSE.txt */
!function(t,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e(require("@tsparticles/engine"));else if("function"==typeof define&&define.amd)define(["@tsparticles/engine"],e);else{var o="object"==typeof exports?e(require("@tsparticles/engine")):e(t.window);for(var i in o)("object"==typeof exports?exports:t)[i]=o[i]}}(this,(t=>(()=>{var e={303:e=>{e.exports=t}},o={};function i(t){var s=o[t];if(void 0!==s)return s.exports;var r=o[t]={exports:{}};return e[t](r,r.exports,i),r.exports}i.d=(t,e)=>{for(var o in e)i.o(e,o)&&!i.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:e[o]})},i.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),i.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var s={};i.r(s),i.d(s,{Light:()=>f,LightArea:()=>g,LightGradient:()=>u,LightShadow:()=>p,loadLightInteraction:()=>m});var r=i(303);const n=1,a=0,l=.5*Math.PI,c=2*Math.PI,d=.25*Math.PI,h="light";class u{constructor(){this.start=new r.OptionsColor,this.stop=new r.OptionsColor,this.start.value="#ffffff",this.stop.value="#000000"}load(t){(0,r.isNull)(t)||(this.start=r.OptionsColor.create(this.start,t.start),this.stop=r.OptionsColor.create(this.stop,t.stop))}}class g{constructor(){this.gradient=new u,this.radius=1e3}load(t){(0,r.isNull)(t)||(this.gradient.load(t.gradient),void 0!==t.radius&&(this.radius=t.radius))}}class p{constructor(){this.color=new r.OptionsColor,this.color.value="#000000",this.length=2e3}load(t){(0,r.isNull)(t)||(this.color=r.OptionsColor.create(this.color,t.color),void 0!==t.length&&(this.length=t.length))}}class f{constructor(){this.area=new g,this.shadow=new p}load(t){(0,r.isNull)(t)||(this.area.load(t.area),this.shadow.load(t.shadow))}}class v extends r.ExternalInteractorBase{constructor(t,e){super(t),this._engine=e}clear(){}init(){}interact(){const t=this.container,e=t.actualOptions,o=t.interactivity;if(!e.interactivity.events.onHover.enable||"pointermove"!==o.status)return;const i=o.mouse.position;i&&t.canvas.draw((e=>{!function(t,e,o){const i=t.actualOptions.interactivity.modes.light?.area;if(!i)return;e.beginPath(),e.arc(o.x,o.y,i.radius,0,c);const s=e.createRadialGradient(o.x,o.y,0,o.x,o.y,i.radius),l=t.canvas.mouseLight;l?.start&&l.stop&&(s.addColorStop(a,(0,r.getStyleFromRgb)(l.start)),s.addColorStop(n,(0,r.getStyleFromRgb)(l.stop)),e.fillStyle=s,e.fill())}(t,e,i)}))}isEnabled(t){const e=this.container,o=e.interactivity.mouse,i=t?.interactivity??e.actualOptions.interactivity,s=i.events;if(!s.onHover.enable||!o.position)return!1;const n=(0,r.isInArray)(h,s.onHover.mode);if(n&&i.modes.light){const t=i.modes.light.area.gradient;e.canvas.mouseLight={start:(0,r.rangeColorToRgb)(this._engine,t.start),stop:(0,r.rangeColorToRgb)(this._engine,t.stop)}}return n}loadModeOptions(t,...e){t.light||(t.light=new f);for(const o of e)t.light.load(o?.light)}reset(){}}class y extends r.ParticlesInteractorBase{constructor(t,e){super(t),this._engine=e}clear(){}init(){}interact(t){const e=this.container,o=e.actualOptions,i=e.interactivity;if(!o.interactivity.events.onHover.enable||"pointermove"!==i.status)return;const s=i.mouse.position;s&&e.canvas.draw((o=>{!function(t,e,o,i){const s=o.getPosition(),n=t.actualOptions.interactivity.modes.light?.shadow;if(!n)return;const a=o.lightShadow;if(!a)return;const h=o.getRadius(),u=o.sides,g=c/u,p=-o.rotation+d,f=[];for(let t=0;t<u;t++)f.push({x:s.x+h*Math.sin(p+g*t)*1,y:s.y+h*Math.cos(p+g*t)*1});const v=[],y=n.length;for(const t of f){const e=Math.atan2(i.y-t.y,i.x-t.x),o={x:t.x+y*Math.sin(-e-l),y:t.y+y*Math.cos(-e-l)};v.push({end:o,start:t})}const m=(0,r.getStyleFromRgb)(a);for(let t=v.length-1,o=0;t>=0;o=t--)e.beginPath(),e.moveTo(v[t].start.x,v[t].start.y),e.lineTo(v[o].start.x,v[o].start.y),e.lineTo(v[o].end.x,v[o].end.y),e.lineTo(v[t].end.x,v[t].end.y),e.fillStyle=m,e.fill()}(e,o,t,s)}))}isEnabled(t){const e=this.container,o=t.interactivity??e.actualOptions.interactivity,i=e.interactivity.mouse,s=o.events;if(!s.onHover.enable||!i.position)return!1;const n=(0,r.isInArray)(h,s.onHover.mode);if(n&&o.modes.light){const e=o.modes.light.shadow;t.lightShadow=(0,r.rangeColorToRgb)(this._engine,e.color)}return n}reset(){}}async function m(t,e=!0){(0,r.assertValidVersion)(t,"3.7.1"),await t.addInteractor("externalLight",(e=>Promise.resolve(new v(e,t))),e),await t.addInteractor("particlesLight",(e=>Promise.resolve(new y(e,t))),e)}return s})()));